# 整体架构

<cite>
**本文档引用的文件**  
- [NettyImApplication.java](file://src/main/java/com/example/nettyim/NettyImApplication.java)
- [SocketIOConfig.java](file://src/main/java/com/example/nettyim/config/SocketIOConfig.java)
- [SocketIOServerManager.java](file://src/main/java/com/example/nettyim/websocket/SocketIOServerManager.java)
- [SocketIOEventHandler.java](file://src/main/java/com/example/nettyim/websocket/SocketIOEventHandler.java)
- [MessageController.java](file://src/main/java/com/example/nettyim/controller/MessageController.java)
- [MessageServiceImpl.java](file://src/main/java/com/example/nettyim/service/impl/MessageServiceImpl.java)
- [MessageMapper.java](file://src/main/java/com/example/nettyim/mapper/MessageMapper.java)
- [UserController.java](file://src/main/java/com/example/nettyim/controller/UserController.java)
- [GlobalExceptionHandler.java](file://src/main/java/com/example/nettyim/exception/GlobalExceptionHandler.java)
- [pom.xml](file://pom.xml)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [MVC分层架构](#mvc分层架构)
4. [实时通信核心流程](#实时通信核心流程)
5. [请求处理链路分析](#请求处理链路分析)
6. [系统上下文图](#系统上下文图)
7. [组件依赖图](#组件依赖图)
8. [高并发性能分析](#高并发性能分析)
9. [结论](#结论)

## 简介
本架构文档详细描述了`netty-im-sample`项目的整体设计，重点阐述基于Spring Boot的MVC分层架构与实时通信机制。系统采用标准的三层架构：Controller层处理HTTP请求，Service层封装业务逻辑，Mapper层与数据库交互。同时，通过WebSocket实现即时通讯功能，支持用户上下线、消息收发、群组聊天等核心场景。文档为初学者提供系统级上下文视图，为高级开发者揭示内部组件依赖关系，并分析系统在高并发场景下的表现特性。

## 项目结构

```mermaid
graph TD
subgraph "src/main/java"
A[com.example.nettyim]
subgraph "config"
B[SocketIOConfig]
C[RedisConfig]
D[MybatisPlusConfig]
end
subgraph "controller"
E[UserController]
F[MessageController]
G[GroupController]
H[FriendshipController]
end
subgraph "service"
I[UserService]
J[MessageService]
K[GroupService]
L[FriendshipService]
end
subgraph "mapper"
M[UserMapper]
N[MessageMapper]
O[GroupMapper]
end
subgraph "websocket"
P[SocketIOEventHandler]
Q[SocketIOServerManager]
end
subgraph "entity"
R[User]
S[Message]
T[Group]
end
subgraph "dto"
U[SendMessageDTO]
V[UserLoginDTO]
end
subgraph "cluster"
W[ClusterMessageRouter]
X[ClusterEvent]
end
end
subgraph "src/main/resources"
Y[application.yml]
Z[schema.sql]
end
A --> B
A --> E
A --> I
A --> M
A --> P
A --> R
A --> U
A --> W
B --> P
E --> I
I --> M
P --> I
P --> Q
Q --> W
```

**图示来源**  
- [SocketIOConfig.java](file://src/main/java/com/example/nettyim/config/SocketIOConfig.java)
- [MessageController.java](file://src/main/java/com/example/nettyim/controller/MessageController.java)
- [MessageServiceImpl.java](file://src/main/java/com/example/nettyim/service/impl/MessageServiceImpl.java)
- [MessageMapper.java](file://src/main/java/com/example/nettyim/mapper/MessageMapper.java)
- [SocketIOServerManager.java](file://src/main/java/com/example/nettyim/websocket/SocketIOServerManager.java)

## MVC分层架构

### Controller层
Controller层负责接收HTTP请求并返回响应，是系统的入口点。各控制器按功能划分，如`UserController`处理用户注册登录，`MessageController`处理消息相关操作。

```mermaid
classDiagram
class UserController {
+register(UserRegisterDTO) Result~User~
+login(UserLoginDTO) Result~Map~
+getUserInfo(Long) Result~User~
+updateUser(Long, UserUpdateDTO) Result~User~
}
class MessageController {
+sendMessage(Long, SendMessageDTO) Result~Message~
+getPrivateMessages(MessageQueryDTO) Result~Page~
+getGroupMessages(MessageQueryDTO) Result~Page~
+markMessagesAsRead(Long, Long[]) Result~String~
}
class GroupController {
+createGroup(CreateGroupDTO) Result~Group~
+getGroupMembers(Long) Result~List~
+addMember(Long, Long) Result~String~
}
class FriendshipController {
+addFriend(AddFriendDTO) Result~String~
+getFriends(Long) Result~List~
+deleteFriend(Long, Long) Result~String~
}
UserController --> UserService : "依赖"
MessageController --> MessageService : "依赖"
GroupController --> GroupService : "依赖"
FriendshipController --> FriendshipService : "依赖"
```

**图示来源**  
- [UserController.java](file://src/main/java/com/example/nettyim/controller/UserController.java)
- [MessageController.java](file://src/main/java/com/example/nettyim/controller/MessageController.java)

### Service层
Service层封装核心业务逻辑，实现具体的功能处理，如用户注册、消息发送、好友关系管理等。

```mermaid
classDiagram
class UserService {
+register(UserRegisterDTO) User
+login(UserLoginDTO) String
+getUserById(Long) User
+updateUser(Long, UserUpdateDTO) User
}
class MessageService {
+sendMessage(Long, SendMessageDTO) Message
+getPrivateMessages(MessageQueryDTO) Page~Message~
+getGroupMessages(MessageQueryDTO) Page~Message~
+markMessagesAsRead(Long, Long[]) void
+recallMessage(Long, Long) void
}
class GroupService {
+createGroup(CreateGroupDTO) Group
+isMember(Long, Long) boolean
+getGroupMembers(Long) User[]
}
class FriendshipService {
+isFriend(Long, Long) boolean
+addFriend(AddFriendDTO) void
+getFriends(Long) User[]
}
MessageService --> MessageMapper : "数据访问"
MessageService --> SocketIOServerManager : "实时推送"
MessageService --> FriendshipService : "权限校验"
MessageService --> GroupService : "权限校验"
```

**图示来源**  
- [MessageServiceImpl.java](file://src/main/java/com/example/nettyim/service/impl/MessageServiceImpl.java)
- [UserService.java](file://src/main/java/com/example/nettyim/service/UserService.java)

### Mapper层
Mapper层基于MyBatis Plus实现，负责与MySQL数据库进行交互，执行CRUD操作。

```mermaid
classDiagram
class UserMapper {
+selectById(Long) User
+insert(User) int
+updateById(User) int
+selectList(QueryWrapper) User[]
}
class MessageMapper {
+selectById(Long) Message
+insert(Message) int
+updateById(Message) int
+selectPage(Page, QueryWrapper) Page~Message~
}
class GroupMapper {
+selectById(Long) Group
+insert(Group) int
}
class FriendshipMapper {
+selectByUserId(Long) Friendship[]
+insert(Friendship) int
}
UserMapper --> User : "实体映射"
MessageMapper --> Message : "实体映射"
GroupMapper --> Group : "实体映射"
FriendshipMapper --> Friendship : "实体映射"
```

**图示来源**  
- [MessageMapper.java](file://src/main/java/com/example/nettyim/mapper/MessageMapper.java)
- [UserMapper.java](file://src/main/java/com/example/nettyim/mapper/UserMapper.java)

## 实时通信核心流程

### WebSocket初始化
系统通过`SocketIOConfig`配置并初始化Socket.IO服务器，支持WebSocket连接。

```mermaid
sequenceDiagram
participant App as Spring应用
participant Config as SocketIOConfig
participant Server as SocketIOServer
participant Redisson as RedissonClient
App->>Config : 启动应用
Config->>Redisson : 创建RedissonClient
Redisson-->>Config : 返回客户端
Config->>Server : 创建SocketIOServer
Server-->>Config : 返回服务器实例
Config-->>App : 注入Bean
```

**图示来源**  
- [SocketIOConfig.java](file://src/main/java/com/example/nettyim/config/SocketIOConfig.java)

### 会话管理机制
`SocketIOServerManager`负责管理用户与客户端的映射关系，维护在线状态。

```mermaid
classDiagram
class SocketIOServerManager {
-userClients : ConcurrentHashMap~Long, SocketIOClient~
-clientUsers : ConcurrentHashMap~String, Long~
-nodeId : String
+getUserClient(Long) : SocketIOClient
+isUserOnline(Long) : boolean
+sendToUser(Long, String, Object) : void
+sendToGroup(Long[], String, Object) : void
+broadcast(String, Object) : void
+getOnlineUserCount() : int
}
class SocketIOEventHandler {
-socketIOServer : SocketIOServer
-messageService : MessageService
-userService : UserService
-socketIOServerManager : SocketIOServerManager
+onSendMessage(SocketIOClient, SendMessageData, AckRequest) : void
+onJoinRoom(SocketIOClient, JoinRoomData, AckRequest) : void
+onTyping(SocketIOClient, TypingData, AckRequest) : void
}
SocketIOEventHandler --> SocketIOServerManager : "消息推送"
SocketIOEventHandler --> MessageService : "业务处理"
SocketIOServerManager --> SocketIOEventHandler : "事件监听"
```

**图示来源**  
- [SocketIOServerManager.java](file://src/main/java/com/example/nettyim/websocket/SocketIOServerManager.java)
- [SocketIOEventHandler.java](file://src/main/java/com/example/nettyim/websocket/SocketIOEventHandler.java)

### 事件处理流程
`SocketIOEventHandler`监听并响应各类WebSocket事件，触发相应业务处理。

```mermaid
flowchart TD
Start([WebSocket连接建立]) --> Connect["onConnect事件"]
Connect --> Extract["提取userId参数"]
Extract --> Validate{"userId有效?"}
Validate --> |否| Disconnect["断开连接"]
Validate --> |是| Check["检查旧连接"]
Check --> Remove["移除旧连接"]
Remove --> Store["存储新连接"]
Store --> Broadcast["广播上线事件"]
Broadcast --> End([连接建立完成])
subgraph "消息发送流程"
MessageStart([客户端发送消息]) --> Handle["onSendMessage事件"]
Handle --> ExtractUser["提取发送者userId"]
ExtractUser --> CreateDTO["创建SendMessageDTO"]
CreateDTO --> CallService["调用messageService.sendMessage()"]
CallService --> SaveDB["保存消息到数据库"]
SaveDB --> Push["推送消息给接收方"]
Push --> Ack["发送确认响应"]
Ack --> End2([消息发送完成])
end
```

**图示来源**  
- [SocketIOEventHandler.java](file://src/main/java/com/example/nettyim/websocket/SocketIOEventHandler.java)
- [MessageServiceImpl.java](file://src/main/java/com/example/nettyim/service/impl/MessageServiceImpl.java)

## 请求处理链路分析

### HTTP请求链路
以发送消息为例，展示从HTTP请求到响应的完整链路。

```mermaid
sequenceDiagram
participant Client as 客户端
participant Controller as MessageController
participant Service as MessageService
participant Mapper as MessageMapper
participant DB as MySQL
participant WebSocket as SocketIOServerManager
Client->>Controller : POST /message/send
Controller->>Service : 调用sendMessage()
Service->>Service : 验证消息权限
Service->>Mapper : 插入消息记录
Mapper->>DB : 执行INSERT语句
DB-->>Mapper : 返回结果
Mapper-->>Service : 消息对象
Service->>WebSocket : sendToUser()/sendToGroup()
WebSocket-->>Client : 推送消息事件
Service-->>Controller : 返回消息对象
Controller-->>Client : 返回成功响应
```

**图示来源**  
- [MessageController.java](file://src/main/java/com/example/nettyim/controller/MessageController.java)
- [MessageServiceImpl.java](file://src/main/java/com/example/nettyim/service/impl/MessageServiceImpl.java)

### WebSocket事件链路
展示WebSocket事件从接收到处理的完整流程。

```mermaid
sequenceDiagram
participant Client as 客户端
participant Server as SocketIOServer
participant Handler as SocketIOEventHandler
participant Service as MessageService
participant Manager as SocketIOServerManager
Client->>Server : emit('send_message', data)
Server->>Handler : 触发onSendMessage
Handler->>Handler : 提取发送者ID
Handler->>Handler : 创建SendMessageDTO
Handler->>Service : 调用sendMessage()
Service->>Service : 业务逻辑处理
Service->>Manager : 推送消息
Manager->>Client : sendEvent('private_message')
Service-->>Handler : 返回消息对象
Handler->>Client : 发送确认响应
```

**图示来源**  
- [SocketIOEventHandler.java](file://src/main/java/com/example/nettyim/websocket/SocketIOEventHandler.java)
- [MessageServiceImpl.java](file://src/main/java/com/example/nettyim/service/impl/MessageServiceImpl.java)

## 系统上下文图

```mermaid
graph TD
subgraph "netty-im-sample 应用"
A[客户端]
B[HTTP Controller]
C[Service Layer]
D[Mapper Layer]
E[WebSocket Handler]
F[SocketIO Server]
end
subgraph "外部系统"
G[(MySQL)]
H[(Redis)]
I[客户端浏览器/APP]
end
I --> A
A --> B
A --> E
B --> C
C --> D
D --> G
E --> C
F --> H
C --> F
F --> I
style A fill:#f9f,stroke:#333
style G fill:#ccf,stroke:#333
style H fill:#cfc,stroke:#333
style I fill:#ffc,stroke:#333
```

**图示来源**  
- [SocketIOConfig.java](file://src/main/java/com/example/nettyim/config/SocketIOConfig.java)
- [RedisConfig.java](file://src/main/java/com/example/nettyim/config/RedisConfig.java)
- [pom.xml](file://pom.xml)

## 组件依赖图

```mermaid
graph TD
A[NettyImApplication] --> B[SocketIOConfig]
A --> C[UserController]
A --> D[MessageController]
A --> E[SocketIOEventHandler]
A --> F[SocketIOServerManager]
B --> G[RedissonClient]
B --> H[SocketIOServer]
C --> I[UserService]
D --> J[MessageService]
E --> J
E --> K[UserService]
E --> F
I --> L[UserMapper]
J --> M[MessageMapper]
J --> N[FriendshipService]
J --> O[GroupService]
J --> F
L --> P[MySQL]
M --> P
N --> Q[FriendshipMapper]
O --> R[GroupMapper]
F --> G
F --> S[ClusterMessageRouter]
style A fill:#f96,stroke:#333
style P fill:#ccf,stroke:#333
style G fill:#cfc,stroke:#333
```

**图示来源**  
- [NettyImApplication.java](file://src/main/java/com/example/nettyim/NettyImApplication.java)
- [SocketIOConfig.java](file://src/main/java/com/example/nettyim/config/SocketIOConfig.java)
- [SocketIOServerManager.java](file://src/main/java/com/example/nettyim/websocket/SocketIOServerManager.java)

## 高并发性能分析

### 架构优势
1. **异步非阻塞I/O**：基于Netty的Socket.IO实现，支持高并发连接
2. **内存映射管理**：使用`ConcurrentHashMap`高效管理用户会话
3. **集群支持**：通过Redisson实现多节点集群部署
4. **分层解耦**：MVC架构清晰分离关注点，便于水平扩展

### 潜在瓶颈
1. **单点推送性能**：`sendToUser`在用户量大时可能成为性能瓶颈
2. **数据库压力**：消息频繁读写对MySQL造成较大压力
3. **内存占用**：大量在线用户时，会话映射表占用较多JVM内存
4. **序列化开销**：WebSocket消息的JSON序列化/反序列化消耗CPU资源

### 优化建议
1. **引入消息队列**：使用Kafka或RabbitMQ解耦消息处理流程
2. **多级缓存**：增加Redis缓存层，减少数据库访问
3. **分库分表**：对消息表进行水平拆分，提升数据库性能
4. **连接压缩**：启用WebSocket压缩，减少网络传输开销
5. **批量处理**：对消息确认、已读标记等操作进行批量处理

## 结论
`netty-im-sample`项目采用清晰的MVC分层架构与WebSocket实时通信机制，实现了完整的即时通讯功能。系统通过Spring Boot提供RESTful API，同时利用Socket.IO实现双向实时通信，支持私聊、群聊等核心场景。架构设计合理，具备良好的可扩展性，通过Redisson支持集群部署。在高并发场景下，系统主要瓶颈在于数据库访问与单点推送性能，建议通过引入消息队列、多级缓存等手段进一步优化性能。整体架构适合中等规模的即时通讯应用，为开发者提供了良好的学习和扩展基础。